---
title: "Workflow with PlantUML"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Workflow with PlantUML}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
 library(plantumlr)
 source("../R/R6PlantUML.R")
 plant = PLANTUML$new(plantuml="C:\\SDK\\plantuml\\plantuml.jar")
```


### Auto  diagramas
```{r}
umlFile = plant$makeUml(plant)
plant$plot(umlFile)
```

### Diagramas dinámicos

Aquellos en los que una parte del diagrama depende del código; por ejemplo, determinadas etiquetas/nombres, lineas de relacion, ...

En estos casos es recomendable crear una plantilla de la definición y modificarla en el propio documento.
Por ejemplo, supongamos que 



Supongamos que tenemos un paquete 'TREE' que, dados ciertos datos, genera un arbol de decision. Este arbol de decision se usa como cualquier otro modelo entrenándolo primero para crear el árbol (`train`) y luego obteniendo el resultado mediante la función genérica `predict`.
El objetivo es mostrar gráficamente el árbol de decisión calculado; logicamente no se puede saber de antemano cuantos nodos va a tener ni cuales son las condiciones, por lo que cada vez que se ejecute train.TREE se generará un nuevo árbol y se deberá mostrar en la documentación.

Supongamos que el paquete nos devuelve la matriz de transición del árbol (`dft') y la de clasificación (`dfc`):

```{r, echo=F}
vars = c("var1", "var2", "var3", "var4", "var5", "var6", "var7")
var1 = c(NA, "> 10", "<= 10", NA     , NA     , NA    , NA)
var2 = c(NA,  NA   , NA     , "== 33", "!= 33", NA    , NA)
var3 = c(NA,  NA   , NA     , NA     , NA     , "TRUE", "FALSE")
var4 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var5 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var6 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var7 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
values = list(var1,var2,var3,var4,var5,var6, var7)
names(values) = vars
dft = t(as.data.frame(values, row.names = vars, stringsAsFactors = F))
```

```{r, echo=F}
types = c("type1", "type2", "type3", "type4", "type5", "type6", "type7", "type8")
var4 =  c("> 10" , "<= 10", NA     , NA     , NA     , NA     ,  NA    ,  NA    )
var5 =  c(NA     ,  NA    , "== 33", "!= 33", NA     , NA     ,  NA    ,  NA    )
var6 =  c(NA     ,  NA    , NA     , NA     , "TRUE" , "FALSE",  NA    ,  NA    )
var7 =  c(NA     ,  NA    , NA     , NA     , NA     , NA     , "== 0" , "!= 0" )
dfc = t(data.frame(var4,var5,var6,var7, stringsAsFactors = F))
colnames(dfc) = types

```

Matriz de transicion
```{r}
 dft
```

Matriz de clasificación
```{r}
dfc
```

Ahora ya es posible generar el diagrama. Para el ejemplo iremos paso a paso

primero los nodos del arbol:

```{r}
umlData = c("skinparam componentStyle uml2", "skinparam packageStyle rectangle")
umlData = c(umlData, unlist(lapply(colnames(dft), function(x) { paste("package", x, "{}")})))
umlFile = plant$asS3PlantUML(umlData, "sample1")
plant$plot(umlFile)
```

Añadimos las categorias

```{r}
umlData = c(umlData, unlist(lapply(colnames(dfc), function(x) { paste("circle ", x)})))
umlFile = plant$asS3PlantUML(umlData)
plant$plot(umlFile)
```


Añadimos las relaciones de la forma: "origen --> destino : texto"

```{r}
relaciones = function(data) {
  # Quitamos filas y columnas que son todo NA
  rr = data[!(apply(data, 1, function(x) all(is.na(x)))),]
  rr = rr[ , ! apply( rr , 2 , function(x) all(is.na(x)) ) ]

  # Extraemos los valores no NA
  ll = lapply(row.names(rr), function(x) x=rr[x, !is.na(rr[x,])])
  names(ll) = row.names(rr)

  # Lo convetimos a vector, cada uno se denomina fila.columna
  ul = unlist(ll)
  
  # Creamos las relaciones origen --> destino : etiqueta
  paste(gsub(".", " --> ", names(ul), fixed=TRUE), ":", ul, collapse="\n")
}

umlData = c(umlData, relaciones(dft), relaciones(dfc))
umlFile = plant$asS3PlantUML(umlData)
plant$plot(umlFile)
```


Y ahora vemos el link

`r plant$link(umlData, "prueba de caption")`

