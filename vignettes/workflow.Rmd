---
title: "Workflow con PlantUML en R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
 #JGG No usamos la linreria para poder probar en desarrollo  
 # library(plantumlr)
 source("../R/R6PlantUML.R")
 source("../R/R6UML.R")
 plant = UML$new(plantuml="C:\\SDK\\plantuml\\plantuml.jar")
```

# Introduccion

En este documento

Si no se está habituado a la generación de diagramas con esta herramienta, o incluso si sí, la primera opción debería ser trabajar con el propio servidor de PlantUML: [Servidor](http://www.plantuml.com/plantuml), el cual permite trabajar con  el diagrama de manera interactiva.

# Flujo de trabajo general

1. Crear un sistema de archivos apropiado para almacenar las definiciones de los diagramas y los diagramas en si mismos.

```
    RProject
    |- .RProject.Rproj
    |- doc1.Rmd
    |- doc2.Rmd
    |- ....
    |- images
    |  |- img1.png
    |  +
    |- diagrams
    |  |- uml
    |  |   |- diagram1.uml
    |  |   |- diagram2.uml
    |  |- images
    |  |   |- diagram1.png
    |  |   |- diagram2.png
    ...
    
```

2. Obtener un diagrama aproximado al objetivo en los ejemplos de PlantUML. El proyecto ofrece en su pagina web una amplia gama de ejemplos operativos que pueden ser modificados en el servidor, cada uno de ellos mostrando el uso de cada una de las caracteristicas de los diferentes diagramas posibles.

3. Comprobar la correcta generación del diagrama anterior en el sistema local. Está comprobado que diagramas que se ejecutan correctamente en la plataforma On Line fallan en el entorno local (usando plantuml.jar)

4. Determinar el tipo de diagrama a realizar


## Tipos de diagramas

Distinguimos los tipos de diagramas a generar en función de sus características y contenidos:

- Estáticos:  No dependen del código o la documentación
- Dinámicos:  Dependen del código ejecutado
- Plantillas: Utilizan una representación común pero difieren en los nombres y etiquetas 

### Diagramas estaticos

Crear el documento de definición de diagrama y almacenar el diagrama en un archivo

### Diagramas dinámicos

Aquellos en los que una parte del diagrama o todo él depende del código que se ejecute. Por ejemplo, queremos mostrar de una forma gráfica un árbol de decisión generado a partir de un cierto conjunto de datos



En estos casos es recomendable crear una plantilla de la definición y modificarla en el propio documento.
Por ejemplo, supongamos que 



Supongamos que tenemos un paquete 'TREE' que, dados ciertos datos, genera un arbol de decision. Este arbol de decision se usa como cualquier otro modelo entrenándolo primero para crear el árbol (`train`) y luego obteniendo el resultado mediante la función genérica `predict`.
El objetivo es mostrar gráficamente el árbol de decisión calculado; logicamente no se puede saber de antemano cuantos nodos va a tener ni cuales son las condiciones, por lo que cada vez que se ejecute train.TREE se generará un nuevo árbol y se deberá mostrar en la documentación.

Supongamos que el paquete nos devuelve la matriz de transición del árbol (`dft') y la de clasificación (`dfc`):

```{r, echo=F}
vars = c("var1", "var2", "var3", "var4", "var5", "var6", "var7")
var1 = c(NA, "> 10", "<= 10", NA     , NA     , NA    , NA)
var2 = c(NA,  NA   , NA     , "== 33", "!= 33", NA    , NA)
var3 = c(NA,  NA   , NA     , NA     , NA     , "TRUE", "FALSE")
var4 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var5 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var6 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
var7 = c(NA,  NA   , NA     , NA     , NA     , NA    , NA)
values = list(var1,var2,var3,var4,var5,var6, var7)
names(values) = vars
dft = t(as.data.frame(values, row.names = vars, stringsAsFactors = F))
```

```{r, echo=F}
types = c("type1", "type2", "type3", "type4", "type5", "type6", "type7", "type8")
var4 =  c("> 10" , "<= 10", NA     , NA     , NA     , NA     ,  NA    ,  NA    )
var5 =  c(NA     ,  NA    , "== 33", "!= 33", NA     , NA     ,  NA    ,  NA    )
var6 =  c(NA     ,  NA    , NA     , NA     , "TRUE" , "FALSE",  NA    ,  NA    )
var7 =  c(NA     ,  NA    , NA     , NA     , NA     , NA     , "== 0" , "!= 0" )
dfc = t(data.frame(var4,var5,var6,var7, stringsAsFactors = F))
colnames(dfc) = types

```

Matriz de transicion
```{r}
 dft
```

Matriz de clasificación
```{r}
dfc
```

Ahora ya es posible generar el diagrama. Para el ejemplo iremos paso a paso

primero los nodos del arbol:

```{r}
umlData = c("skinparam componentStyle uml2", "skinparam packageStyle rectangle")
umlData = c(umlData, unlist(lapply(colnames(dft), function(x) { paste("package", x, "{}")})))
umlFile = plant$asS3PlantUML(umlData, "sample1")
plant$plot(umlFile)
```

Añadimos las categorias

```{r}
umlData = c(umlData, unlist(lapply(colnames(dfc), function(x) { paste("circle ", x)})))
umlFile = plant$asS3PlantUML(umlData)
plant$plot(umlFile)
```


Añadimos las relaciones

```{r, echo=FALSE, fig.cap = "Diagrama UML completo"}
relaciones = function(data) {
  # Quitamos filas y columnas que son todo NA
  rr = data[!(apply(data, 1, function(x) all(is.na(x)))),]
  rr = rr[ , ! apply( rr , 2 , function(x) all(is.na(x)) ) ]

  # Extraemos los valores no NA
  ll = lapply(row.names(rr), function(x) x=rr[x, !is.na(rr[x,])])
  names(ll) = row.names(rr)

  # Lo convetimos a vector, cada uno se denomina fila.columna
  ul = unlist(ll)
  
  # Creamos las relaciones origen --> destino : etiqueta
  paste(gsub(".", " --> ", names(ul), fixed=TRUE), ":", ul, collapse="\n")
}

umlData = c(umlData, relaciones(dft), relaciones(dfc))
umlFile = plant$asS3PlantUML(umlData)
plant$plot(umlFile)
```

